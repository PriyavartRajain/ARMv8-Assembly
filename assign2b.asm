/*Submitted by: Priyavart Rajain
Course:		CPSC 355 Spring 2020
University of Calgary
*/

/* Defining the macros for registers */ 

define(count,x20)
define(randInt,x21)
define(min,x22)
define(max,x23)
define(sum,x24)
define(divisor,x25)
define(quotient,x26)

input:		.string	"\nEnter the value of n:\t"			// initializing string input used to prompt user for n		
formatIn:	.string "%d"						// initializing string formatIn used in scanf
output:		.string "\nMin: %d\nMax: %d\nSum: %d\n\n"			// initializing string output used to display final result
randomNum:	.string "Current integer is: %d\n"			// initializing string randomNum to display the random number generated with each iteration of the loop

		.data							// Write part of data
n:		.word 0							// initializing variable n of size word with value 0

		.text							// read only part of the code
		.balign 4						// aligns the instructions
		.global main						// makes main globally accessible
		

main:		stp 	x29, x30,[sp, -16]!				// storing x29 and x30 on the stack by preincrementing it 16 bytes
		mov 	x29, sp						// store stack pointer in x29
	
		adrp 	x0, input					// Sets the first argument for printf as the string called "input" 
		add 	x0,x0, :lo12:input				// Sets the lower 12 bits of x0 as input 
		bl 	printf						// Calling the printf function

		adrp 	x0, formatIn					// Takes n as input using scanf
		add 	x0, x0, :lo12:formatIn				// First argument to scanf is the format string, formatIn
		adr 	x1, n						// x1 is the second  argument, and stores the address of n
		bl 	scanf						// scanf stores the input in n
					
		adr 	x1, n						// adr grabs the address of n and saves it to x1
		ldr 	x19, [x1]					// loading the value of x1 i.e n , into x19, 
	
		mov 	count, 0					// set count = 0
		mov 	min, 0						// set min = 0
		mov 	max, 0						// set max = 0
		mov 	sum, 0						// set sum = 0
		mov 	divisor, 0xFF					// divisor holds the value 0xFF i.e 255 in decimal
		mov 	quotient, 0					// quotient will store the result of unsigned division between the random number 
									// - stored by rand in x0 and 0xFF which is stored in divisor
	
		mov 	x0, xzr						// now we populate x0 with 0's because value in x0 is automatically passed to time when we call it 
		bl 	time						// calling time function, value in x0 is passed automatically under the hood
		bl 	srand						// calling srand, which takes in time as an argument automatically
		b 	test						// branch to loop test 

			
									// Formula to find the mod of random number: 
									// randNum - ( quotient * divisor ), where quotient = udiv of randNum and 0xFF, and divisor = 0xFF
									
body:		bl 	rand						// calling the rand function, the random number generated will be stored in x0 automatically
		udiv 	quotient, x0, divisor				// unsigned division of random number in x0 by 0xFF which is in divisor
		msub 	randInt, quotient, divisor, x0			// calculating and storing the mod in x21:
									// x21 = x0 - (x26 * x25)	
									// x26: The Quotient, x25: The divisor, x0: The random number generated by rand
		
		adrp 	x0, randomNum					// Sets the first argument for printf as the string called "randomNum"	
		add 	x0,x0, :lo12:randomNum				// Sets the lower 12 bits of x0 as randomNum
		mov 	x1,randInt					// Sets the secomd argument of printf as randInt
		bl 	printf						// calling the printf function				
		
		cmp 	count, xzr					// if count == 0 , branch to equate
		b.eq 	equate
		
		cmp 	randInt,min					// else if current integer < min , branch to setmin
		b.lt 	setmin

		cmp 	randInt,max					// else if current integer > max , branch to setmax
		b.gt 	setmax

		b 	continue					// else, branch to continue	
				
equate: 	mov 	min, randInt					// if it is the first iteration of the loop, set min = current integer and max = current integer
		mov 	max, randInt
		b 	continue					// Once done, branch to continue

setmin:		mov 	min, randInt					// If current integer is less than min, update the min value to current integer and then continue
		b 	continue					// Once done, branch to continue

setmax: 	mov 	max, randInt					// If current integer is greater than max, update the max value to current integer and then continue
		b 	continue					// Once done, branch to continue

continue: 	add 	sum,sum,randInt					// update sum = sum + current integer
	  	add 	count,count, 1					// incrementing the value of count by 1 each time	  
	  	b 	test						// branching to test labelto check if count<N

test:		cmp 	count,x19					// compares count to n
		b.lt 	body						// if count < n , branch to body of the loop
		b.eq 	done						// once count becomes equal to n, we step out of the loop and branch to done


done:		adrp 	x0, output					// This label is reached when count becomes equal to n
		add 	x0, x0, :lo12:output				// Printing the min,max and sum values
		mov 	x1, min						// storing min value in second parameter, first being the format string itself
		mov 	x2, max						// storing max value in third parameter
		mov 	x3, sum						// storing sum value in fourth parameter
		bl 	printf

		mov 	w0,0						// restoring the system state
		ldp 	x29, x30, [sp], 16				// deallocate memory from the stack
		ret							// return to the original system state



